import {
  __commonJS
} from "./chunk-FM7WUVZV.js";

// node_modules/openapi-fetch/dist/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/openapi-fetch/dist/cjs/index.cjs"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      createFinalURL: () => createFinalURL,
      createQuerySerializer: () => createQuerySerializer,
      default: () => createClient,
      defaultBodySerializer: () => defaultBodySerializer,
      defaultPathSerializer: () => defaultPathSerializer,
      mergeHeaders: () => mergeHeaders,
      randomID: () => randomID,
      serializeArrayParam: () => serializeArrayParam,
      serializeObjectParam: () => serializeObjectParam,
      serializePrimitiveParam: () => serializePrimitiveParam
    });
    module.exports = __toCommonJS(src_exports);
    var DEFAULT_HEADERS = {
      "Content-Type": "application/json"
    };
    var PATH_PARAM_RE = /\{[^{}]+\}/g;
    var CustomRequest = class extends Request {
      constructor(input, init) {
        super(input, init);
        for (const key in init) {
          if (!(key in this)) {
            this[key] = init[key];
          }
        }
      }
    };
    function randomID() {
      return Math.random().toString(36).slice(2, 11);
    }
    function createClient(clientOptions) {
      let {
        baseUrl = "",
        fetch: baseFetch = globalThis.fetch,
        querySerializer: globalQuerySerializer,
        bodySerializer: globalBodySerializer,
        headers: baseHeaders,
        ...baseOptions
      } = { ...clientOptions };
      if (baseUrl.endsWith("/")) {
        baseUrl = baseUrl.substring(0, baseUrl.length - 1);
      }
      baseHeaders = mergeHeaders(DEFAULT_HEADERS, baseHeaders);
      const middlewares = [];
      async function coreFetch(schemaPath, fetchOptions) {
        const {
          fetch = baseFetch,
          headers,
          params = {},
          parseAs = "json",
          querySerializer: requestQuerySerializer,
          bodySerializer = globalBodySerializer ?? defaultBodySerializer,
          ...init
        } = fetchOptions || {};
        let querySerializer = typeof globalQuerySerializer === "function" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);
        if (requestQuerySerializer) {
          querySerializer = typeof requestQuerySerializer === "function" ? requestQuerySerializer : createQuerySerializer({
            ...typeof globalQuerySerializer === "object" ? globalQuerySerializer : {},
            ...requestQuerySerializer
          });
        }
        const requestInit = {
          redirect: "follow",
          ...baseOptions,
          ...init,
          headers: mergeHeaders(baseHeaders, headers, params.header)
        };
        if (requestInit.body) {
          requestInit.body = bodySerializer(requestInit.body);
          if (requestInit.body instanceof FormData) {
            requestInit.headers.delete("Content-Type");
          }
        }
        let id;
        let options;
        let request = new CustomRequest(createFinalURL(schemaPath, { baseUrl, params, querySerializer }), requestInit);
        if (middlewares.length) {
          id = randomID();
          options = Object.freeze({
            baseUrl,
            fetch,
            parseAs,
            querySerializer,
            bodySerializer
          });
          for (const m of middlewares) {
            if (m && typeof m === "object" && typeof m.onRequest === "function") {
              const result = await m.onRequest({
                request,
                schemaPath,
                params,
                options,
                id
              });
              if (result) {
                if (!(result instanceof Request)) {
                  throw new Error("onRequest: must return new Request() when modifying the request");
                }
                request = result;
              }
            }
          }
        }
        let response = await fetch(request);
        if (middlewares.length) {
          for (let i = middlewares.length - 1; i >= 0; i--) {
            const m = middlewares[i];
            if (m && typeof m === "object" && typeof m.onResponse === "function") {
              const result = await m.onResponse({
                request,
                response,
                schemaPath,
                params,
                options,
                id
              });
              if (result) {
                if (!(result instanceof Response)) {
                  throw new Error("onResponse: must return new Response() when modifying the response");
                }
                response = result;
              }
            }
          }
        }
        if (response.status === 204 || response.headers.get("Content-Length") === "0") {
          return response.ok ? { data: {}, response } : { error: {}, response };
        }
        if (response.ok) {
          if (parseAs === "stream") {
            return { data: response.body, response };
          }
          return { data: await response[parseAs](), response };
        }
        let error = await response.text();
        try {
          error = JSON.parse(error);
        } catch {
        }
        return { error, response };
      }
      return {
        /** Call a GET endpoint */
        GET(url, init) {
          return coreFetch(url, { ...init, method: "GET" });
        },
        /** Call a PUT endpoint */
        PUT(url, init) {
          return coreFetch(url, { ...init, method: "PUT" });
        },
        /** Call a POST endpoint */
        POST(url, init) {
          return coreFetch(url, { ...init, method: "POST" });
        },
        /** Call a DELETE endpoint */
        DELETE(url, init) {
          return coreFetch(url, { ...init, method: "DELETE" });
        },
        /** Call a OPTIONS endpoint */
        OPTIONS(url, init) {
          return coreFetch(url, { ...init, method: "OPTIONS" });
        },
        /** Call a HEAD endpoint */
        HEAD(url, init) {
          return coreFetch(url, { ...init, method: "HEAD" });
        },
        /** Call a PATCH endpoint */
        PATCH(url, init) {
          return coreFetch(url, { ...init, method: "PATCH" });
        },
        /** Call a TRACE endpoint */
        TRACE(url, init) {
          return coreFetch(url, { ...init, method: "TRACE" });
        },
        /** Register middleware */
        use(...middleware) {
          for (const m of middleware) {
            if (!m) {
              continue;
            }
            if (typeof m !== "object" || !("onRequest" in m || "onResponse" in m)) {
              throw new Error("Middleware must be an object with one of `onRequest()` or `onResponse()`");
            }
            middlewares.push(m);
          }
        },
        /** Unregister middleware */
        eject(...middleware) {
          for (const m of middleware) {
            const i = middlewares.indexOf(m);
            if (i !== -1) {
              middlewares.splice(i, 1);
            }
          }
        }
      };
    }
    function serializePrimitiveParam(name, value, options) {
      if (value === void 0 || value === null) {
        return "";
      }
      if (typeof value === "object") {
        throw new Error(
          "Deeply-nested arrays/objects arenâ€™t supported. Provide your own `querySerializer()` to handle these."
        );
      }
      return `${name}=${(options == null ? void 0 : options.allowReserved) === true ? value : encodeURIComponent(value)}`;
    }
    function serializeObjectParam(name, value, options) {
      if (!value || typeof value !== "object") {
        return "";
      }
      const values = [];
      const joiner = {
        simple: ",",
        label: ".",
        matrix: ";"
      }[options.style] || "&";
      if (options.style !== "deepObject" && options.explode === false) {
        for (const k in value) {
          values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));
        }
        const final2 = values.join(",");
        switch (options.style) {
          case "form": {
            return `${name}=${final2}`;
          }
          case "label": {
            return `.${final2}`;
          }
          case "matrix": {
            return `;${name}=${final2}`;
          }
          default: {
            return final2;
          }
        }
      }
      for (const k in value) {
        const finalName = options.style === "deepObject" ? `${name}[${k}]` : k;
        values.push(serializePrimitiveParam(finalName, value[k], options));
      }
      const final = values.join(joiner);
      return options.style === "label" || options.style === "matrix" ? `${joiner}${final}` : final;
    }
    function serializeArrayParam(name, value, options) {
      if (!Array.isArray(value)) {
        return "";
      }
      if (options.explode === false) {
        const joiner2 = { form: ",", spaceDelimited: "%20", pipeDelimited: "|" }[options.style] || ",";
        const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner2);
        switch (options.style) {
          case "simple": {
            return final;
          }
          case "label": {
            return `.${final}`;
          }
          case "matrix": {
            return `;${name}=${final}`;
          }
          default: {
            return `${name}=${final}`;
          }
        }
      }
      const joiner = { simple: ",", label: ".", matrix: ";" }[options.style] || "&";
      const values = [];
      for (const v of value) {
        if (options.style === "simple" || options.style === "label") {
          values.push(options.allowReserved === true ? v : encodeURIComponent(v));
        } else {
          values.push(serializePrimitiveParam(name, v, options));
        }
      }
      return options.style === "label" || options.style === "matrix" ? `${joiner}${values.join(joiner)}` : values.join(joiner);
    }
    function createQuerySerializer(options) {
      return function querySerializer(queryParams) {
        const search = [];
        if (queryParams && typeof queryParams === "object") {
          for (const name in queryParams) {
            const value = queryParams[name];
            if (value === void 0 || value === null) {
              continue;
            }
            if (Array.isArray(value)) {
              search.push(
                serializeArrayParam(name, value, {
                  style: "form",
                  explode: true,
                  ...options == null ? void 0 : options.array,
                  allowReserved: (options == null ? void 0 : options.allowReserved) || false
                })
              );
              continue;
            }
            if (typeof value === "object") {
              search.push(
                serializeObjectParam(name, value, {
                  style: "deepObject",
                  explode: true,
                  ...options == null ? void 0 : options.object,
                  allowReserved: (options == null ? void 0 : options.allowReserved) || false
                })
              );
              continue;
            }
            search.push(serializePrimitiveParam(name, value, options));
          }
        }
        return search.join("&");
      };
    }
    function defaultPathSerializer(pathname, pathParams) {
      let nextURL = pathname;
      for (const match of pathname.match(PATH_PARAM_RE) ?? []) {
        let name = match.substring(1, match.length - 1);
        let explode = false;
        let style = "simple";
        if (name.endsWith("*")) {
          explode = true;
          name = name.substring(0, name.length - 1);
        }
        if (name.startsWith(".")) {
          style = "label";
          name = name.substring(1);
        } else if (name.startsWith(";")) {
          style = "matrix";
          name = name.substring(1);
        }
        if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {
          continue;
        }
        const value = pathParams[name];
        if (Array.isArray(value)) {
          nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));
          continue;
        }
        if (typeof value === "object") {
          nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));
          continue;
        }
        if (style === "matrix") {
          nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);
          continue;
        }
        nextURL = nextURL.replace(match, style === "label" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));
      }
      return nextURL;
    }
    function defaultBodySerializer(body) {
      if (body instanceof FormData) {
        return body;
      }
      return JSON.stringify(body);
    }
    function createFinalURL(pathname, options) {
      var _a;
      let finalURL = `${options.baseUrl}${pathname}`;
      if ((_a = options.params) == null ? void 0 : _a.path) {
        finalURL = defaultPathSerializer(finalURL, options.params.path);
      }
      let search = options.querySerializer(options.params.query ?? {});
      if (search.startsWith("?")) {
        search = search.substring(1);
      }
      if (search) {
        finalURL += `?${search}`;
      }
      return finalURL;
    }
    function mergeHeaders(...allHeaders) {
      const finalHeaders = new Headers();
      for (const h of allHeaders) {
        if (!h || typeof h !== "object") {
          continue;
        }
        const iterator = h instanceof Headers ? h.entries() : Object.entries(h);
        for (const [k, v] of iterator) {
          if (v === null) {
            finalHeaders.delete(k);
          } else if (Array.isArray(v)) {
            for (const v2 of v) {
              finalHeaders.append(k, v2);
            }
          } else if (v !== void 0) {
            finalHeaders.set(k, v);
          }
        }
      }
      return finalHeaders;
    }
  }
});

// node_modules/portone/dist/index.js
var require_dist = __commonJS({
  "node_modules/portone/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var f = require_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var f__default = _interopDefault(f);
    var y = "https://api.portone.io";
    function g(n, e, t) {
      if (!e && t) {
        let a = () => {
          throw new Error("PortOne SDK is not authorized yet. Please run login function to authorize.");
        };
        return { GET: a, PUT: a, POST: a, DELETE: a, OPTIONS: a, HEAD: a, PATCH: a, TRACE: a, use: () => {
        }, eject: () => {
        } };
      }
      return f__default.default({ baseUrl: n, headers: { Authorization: e } });
    }
    var p = g;
    var c = (n) => ({ token: (e) => n.POST("/login/api-secret", { body: e }), tokenRefresh: (e) => n.POST("/token/refresh", { body: e }) });
    var d = (n, e) => ({ preRegisterPayment: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/pre-register", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, getPayment: (t) => n.GET("/payments/{paymentId}", { params: { path: { paymentId: t.paymentId }, query: { storeId: e == null ? void 0 : e.storeId } } }), getPayments: (t) => {
      var a;
      return n.GET("/payments", { body: t ? { page: { ...t.page }, filter: { ...t.filter, storeId: ((a = t.filter) == null ? void 0 : a.storeId) || (e == null ? void 0 : e.storeId) || void 0 } } : {} });
    }, getPaymentsByCursor: (t) => n.GET("/payments-by-cursor", { body: t ? { ...t, storeId: t.storeId || (e == null ? void 0 : e.storeId) || void 0 } : {} }), cancelPayment: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/cancel", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, payWithBillingKey: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/billing-key", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, keyInPayment: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/instant", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, closeVbank: (t) => n.POST("/payments/{paymentId}/virtual-account/close", { params: { path: { paymentId: t.paymentId }, query: { storeId: e == null ? void 0 : e.storeId } } }), resendWebhook: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/resend-webhook", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, registerStoreReceipt: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/register-store-receipt", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    } });
    var o = (n, e) => ({ registerEscrowLogistics: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/escrow/logistics", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, updateEscrowLogistics: (t) => {
      let { paymentId: a, ...s } = t;
      return n.PATCH("/payments/{paymentId}/escrow/logistics", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, confirmEscrow: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/escrow/complete", { params: { path: { paymentId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    } });
    var m = (n, e) => ({ getPaymentSchedule: (t) => n.GET("/payment-schedules/{paymentScheduleId}", { params: { path: { paymentScheduleId: t.paymentScheduleId }, query: { storeId: e == null ? void 0 : e.storeId } } }), getPaymentSchedules: (t) => {
      var s;
      let a = t ? { page: { ...t.page }, filter: { ...t.filter, storeId: ((s = t.filter) == null ? void 0 : s.storeId) || (e == null ? void 0 : e.storeId) || void 0 } } : {};
      return n.GET("/payment-schedules", { body: a || {} });
    }, revokePaymentSchedule: (t) => n.DELETE("/payment-schedules", { body: { ...t, storeId: t.storeId || (e == null ? void 0 : e.storeId) || void 0 } }), schedulePayment: (t) => {
      let { paymentId: a, ...s } = t;
      return n.POST("/payments/{paymentId}/schedule", { params: { path: { paymentId: a } }, body: { ...s, payment: { ...s.payment, storeId: s.payment.storeId || (e == null ? void 0 : e.storeId) || void 0 } } });
    } });
    var h = (n, e) => ({ getBillingKey: (t) => n.GET("/billing-keys/{billingKey}", { params: { path: { billingKey: t.billingKey }, query: { storeId: e == null ? void 0 : e.storeId } } }), deleteBillingKey: (t) => n.DELETE("/billing-keys/{billingKey}", { params: { path: { billingKey: t.billingKey }, query: { storeId: e == null ? void 0 : e.storeId } } }), getBillingKeys: (t) => {
      var a;
      return n.GET("/billing-keys", { body: { ...t, filter: { ...t.filter, storeId: ((a = t.filter) == null ? void 0 : a.storeId) || (e == null ? void 0 : e.storeId) || void 0 } } });
    }, issueBillingKey: (t) => n.POST("/billing-keys", { body: { ...t, storeId: t.storeId || (e == null ? void 0 : e.storeId) || void 0 } }) });
    var u = (n, e) => ({ getCashReceipt: (t) => n.GET("/payments/{paymentId}/cash-receipt", { params: { path: { paymentId: t.paymentId }, query: { storeId: e == null ? void 0 : e.storeId } } }), issueCashReceipt: (t) => n.POST("/cash-receipts", { body: { ...t, storeId: t.storeId || (e == null ? void 0 : e.storeId) || void 0 } }), cancelCashReceipt: (t) => n.POST("/payments/{paymentId}/cash-receipt/cancel", { params: { path: { paymentId: t.paymentId }, query: { storeId: e == null ? void 0 : e.storeId } } }) });
    var I = (n, e) => ({ getIdentityVerification: (t) => n.GET("/identity-verifications/{identityVerificationId}", { params: { path: { identityVerificationId: t.identityVerificationId }, query: { storeId: e == null ? void 0 : e.storeId } } }), sendIdentityVerification: (t) => {
      let { identityVerificationId: a, ...s } = t;
      return n.POST("/identity-verifications/{identityVerificationId}/send", { params: { path: { identityVerificationId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, confirmIdentityVerification: (t) => {
      let { identityVerificationId: a, ...s } = t;
      return n.POST("/identity-verifications/{identityVerificationId}/confirm", { params: { path: { identityVerificationId: a } }, body: { ...s, storeId: s.storeId || (e == null ? void 0 : e.storeId) || void 0 } });
    }, resendIdentityVerification: (t) => n.POST("/identity-verifications/{identityVerificationId}/resend", { params: { path: { identityVerificationId: t.identityVerificationId }, query: { storeId: e == null ? void 0 : e.storeId } } }) });
    var l = (n) => ({ getKakaopayPaymentOrder: (e) => n.GET("/kakaopay/payment/order", { params: { query: e } }) });
    var i = class {
      constructor(e) {
        this.host = (e == null ? void 0 : e.host) || y, this._request = p(this.host, void 0, true), this._init();
      }
      _init() {
        let e = { storeId: this.storeId || void 0 };
        this.auth = c(this._request), this.payments = d(this._request, e), this.escrow = o(this._request, e), this.paymentSchedules = m(this._request, e), this.billingKeys = h(this._request, e), this.cashReceipts = u(this._request, e), this.identifyVerifications = I(this._request, e), this.forSpecificPg = l(this._request);
      }
      async login(e) {
        var t, a, s;
        if (this.storeId = e.storeId, e.authorization.type === "ACCESS_TOKEN") {
          let r = await this._request.POST("/login/api-secret", { body: { apiSecret: e.authorization.secret } });
          if (!((t = r.data) != null && t.accessToken) || r.error) throw new Error(r.error ? `${(a = r.error) == null ? void 0 : a.type}: ${(s = r.error) == null ? void 0 : s.message}` : "Failed to get access token");
          this.authorization = { secret: r.data.accessToken, type: e.authorization.type || "SECRET" }, this._request = p(this.host, `Bearer ${this.authorization.secret}`);
        } else this.authorization = e.authorization, this._request = p(this.host, `PortOne ${this.authorization.secret}`);
        this._init();
      }
    };
    var D = i;
    exports.PortOne = i;
    exports.default = D;
  }
});
export default require_dist();
//# sourceMappingURL=portone.js.map
